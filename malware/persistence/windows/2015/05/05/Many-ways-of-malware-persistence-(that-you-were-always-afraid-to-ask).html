<!DOCTYPE html>
<html class="direction--ltr"lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Many ways of malware persistence (that you were always afraid to ask) | Jump ESP, jump!</title>
<meta name="generator" content="Jekyll v4.0.1" />
<meta property="og:title" content="Many ways of malware persistence (that you were always afraid to ask)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="TL;DR: Are you into red teaming? Need persistence? This post is not that long, read it ;) Are you into blue teaming? Have to find those pesky backdoors? This post is not that long, read it ;) In the previous post, I listed different ways how a Windows domain/forest can be backdoored. In this new post, I am digging a bit deeper, and list the most common/known ways malware can survive a reboot, just using local resources of the infected Windows system. The list is far from complete, and I would like to encourage everyone to comment on new methods, not yet listed here. From an incident response point of view, one of the best strategies to find malware on a suspicious system is to search for suspicious entries that start with the system. In the good old days, you had to check for 2-3 locations to cover 99% of the infections. Nowadays, there are a thousand ways malware can start. The common ones automatically start whenever Windows starts (or the user logs in), but some tricky ones are triggered by other events. AutorunsMy favorite choice when it comes to malware persistence is Sysinternals tools, Autoruns. In this paragraph, I mainly quote the official built-in help, but bear with me, it is still interesting.On a side note, there are some problems with the Autoruns tool: it can only run on a live system. (EDIT: This is not true, Autoruns can analyze offline systems as well! Thanks to a comment from Justin.) And usually, this is not the case - I usually have dd images. And although VBoxManage can convert the dd images to VirtualBox disk image format, usually I don&#39;t have the time and storage to do that. This is where xmount awesomeness is here to rescue the day. It can convert dd and Encase images on-the-fly in-memory to Virtualbox format. Just attach the disk image to a new Virtualbox machine as the main boot HDD, modify the CPU/disk/controller settings until Windows starts instead of crashing, and voila, you can boot your forensic image - without modifying a single bit on the original evidence dd file. Another problem with malware analysis on a live system is that a good rootkit can fool the analyst easily. For quick wins, I usually filter out Microsoft entries, look for per-user locations only and check for unverified (missing or invalid Authenticode) executables. This usually helps to find 90% of malware easily. Especially if it has a color like purple or pink, it is highly suspicious. To find the rest, well, one has to dig deeper.Zeus &quot;hiding&quot; in the usual random directory - check the faked timestampTo implement &quot;poor-mans monitoring&quot;, regularly save the output of Autoruns, and during incident response, it will be highly valuable. Howto guide here.Logon&quot;This entry results in scans of standard autostart locations such as the Startup folder for the current user and all users, the Run Registry keys, and standard application launch locations.&quot; There are 42 registry keys/folders at the moment in Autoruns, which can be used to autostart a malware. The most common ways are the HKCU\Software\Microsoft\Windows\CurrentVersion\Run and the C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup folder.One of my favorite regarding this topic is the file-less Poweliks malware, 100% pure awesomeness. Typical ring 3 code execution.Explorer&quot;Select this entry to see Explorer shell extensions, browser helper objects, explorer toolbars, active setup executions, and shell execute hooks&quot;. 71 registry keys, OMG. Usually, this is not about auto-malware execution, but some of them might be a good place to hide malware.Internet explorer&quot;This entry shows Browser Helper Objects (BHO&#39;s), Internet Explorer toolbars and extensions&quot;. 13 registry key here. If a malicious BHO is installed into your browser, you are pretty much screwed.Scheduled tasks&quot;Task scheduler tasks configured to start at boot or logon.&quot; Not commonly used, but it is important to look at this.I always thought this part of the autostart entries is quite boring, but nowadays, I think it is one of the best ways to hide your malware. There are so many entries here by default, and some of them can use quite good tricks to trigger the start.Did you know that you can create custom events that trigger on Windows event logs?Did you know you can create malware persistence just by using Windows tools like bitsadmin and Scheduled tasks?Scheduler in the old daysScheduler in the new daysServicesHKLM\System\CurrentControlSet\Services is a very commonplace to hide malware, especially rootkits. Check all entries with special care.DriversSame as services. Very commonplace for rootkits. Unfortunately, signing a driver for 64-bit systems is not fun anymore, as it has to be signed by certificates that can be chained back to &quot;Software Publisher Certificates&quot;. Typical startup place for Ring 0 rootkits. Starting from Windows 10, even this will change and all drivers have to be signed by &quot;Windows Hardware Developer Center Dashboard portal&quot; and EV certificates.Codecs22 registry keys. Not very common, but possible code execution.Boot execute&quot;Native images (as opposed to Windows images) that run early during the boot process.&quot;5 registry keys here. Good place to hide a rootkit here.Image hijacks&quot;Image file execution options and command prompt autostarts.&quot; 13 registry key here. I believe this was supposed for debugging purposes originally.This is where the good-old sticky keys trick is hiding. It is a bit different from the others, as it provides a backdoor access, but you can only use this from the local network (usually). The trick is to execute your code whenever someone presses the SHIFT key multiple times before logging into RDP. The old way was to replace the sethc.exe, the new fun is to set a debug program on sethc. If you see this, you are in troubleAppInit&quot;This has Autoruns shows DLLs registered as application initialization DLLs.&quot; Only 3 registry keys here. This is the good old way to inject a malicious DLL into Explorer, browsers, etc. Luckily it is going to be deprecated soon.Known DLLs&quot;This reports the location of DLLs that Windows loads into applications that reference them.&quot; Only 1 registry key. This might be used to hijack some system DLLs.Winlogon&quot;Shows DLLs that register for Winlogon notification of logon events.&quot; 7 registry keys. Sometimes used by malware.Winsock providers&quot;Shows registered Winsock protocols, including Winsock service providers. Malware often installs itself as a Winsock service provider because there are few tools that can remove them. Autoruns can disable them, but cannot delete them.&quot; 4 registry keys. AFAIK this was trendy a while ago. But still, a good place to hide malware.Print monitors&quot;Displays DLLs that load into the print spooling service. Malware has used this support to autostart itself.&quot; 1 registry key. Some malware writers are quite creative when it comes to hiding their persistence module.LSA providers&quot;Shows registers Local Security Authority (LSA) authentication, notification and security packages.&quot; 5 registry keys. A good place to hide your password stealer. Network providers&quot;Missing documentation&quot;. If you have a good 1 sentence documentation, please comment.WMI filters&quot;Missing documentation&quot;. Check Mandiant for details.Sidebar gadgetsThank god MS disabled this a while ago :)We all miss you, you crappy resource gobble nightmaresCommon ways - not in autorunsNow, let&#39;s see other possibilities to start your malware, which won&#39;t be listed in Sysinternals Autoruns.Backdoor an executable/DLLJust change the code of an executable which is either auto-starting or commonly started by the user. To avoid lame mistakes, disable the update of the file ... The backdoor factory is a good source for this task. But if you backdoor an executable/DLL which is already in Autoruns listed, you will break the Digital Signature on the file. It is recommended to sign your executable, and if you can&#39;t afford to steal a trusted certificate, you can still import your own CA into the user&#39;s trusted certificate store (with user privileges), and it will look like a trusted one. Protip: Use &quot;Microsoft Windows&quot; as the codesigner CA, and your executable will blend in.See, rootkit.exe totally looks legit, and it is filtered out when someone filters for &quot;Hide Windows entries&quot;.Hijack DLL load orderJust place your DLL into a directory which is searched before the original DLL is found, and PROFIT! But again, to avoid lame detection, be sure to proxy the legitimate function calls to the original DLL. A good source on this topic from Mandiant and DLL hijack detector.Here you can see how PlugX works in action, by dropping a legitimate Kaspersky executable, and hijacking the DLL calls with their DLL. Hijack a shortcut from the desktop/start menuNever underestimate the power of lame tricks. Just create an executable which calls the original executable, and meanwhile starts your backdoor. Replace the link, PROFIT! And don&#39;t be a skiddie, check the icon ;) I have seen this trick in adware hijacking browsers a lot of times.IE hijacked to start with http://tinyurl.com/2fcpre6File association hijackChoose the user&#39;s favorite file type, replace the program which handles the opening with a similar one described in the previous section, and voila!COM object hijackThe main idea is that some COM objects are scanned for whether they are on the system or not, and when it is registered, it is automatically loaded. See COMpfun for details.Windows Application Compatibility - SHIMNot many people are familiar with Windows Application Compatibility and how it works. Think about it as an added layer between applications and the OS. If the application matches a certain condition (e.g. filename), certain actions will take place. E.g. emulation of directories, registry entries, DLL injection, etc. In my installation, there are 367 different compatibility fixes (type of compatibility &quot;simulation&quot;), and some of those can be customized.Every time IE starts, inject a DLL into IEBootkits Although bootkits shown here can end up in Autoruns in the drivers section (as they might need a driver at the end of the day), I still think it deserves a different section.MBR - Master boot recordMalware can overwrite the Master boot record, start the boot process with its own code, and continue the boot process with the original one. It is common for rootkits to fake the content of the MBR record, and show the original contents. Which means one just have attached the infected HDD to a clean system, and compare the first 512 bytes (or more in some cases) with a known, clean state, or compare it to the contents shown from the infected OS. SecureBoot can be used to prevent malware infections like this.There is a slight difference when MBR is viewed from infected OS vs clean OSVBR - Volume boot recordThis is the next logical step where malware can start it&#39;s process, and some malware/rootkit prefers to hide it&#39;s startup code here. Check GrayFish for details. SecureBoot can be used to prevent malware infections like this.BIOS/UEFI malwareBoth the old BIOS and the new UEFI can be modified in a way that malware starts even before the OS had a chance to run. Although UEFI was meant to be more secure than BIOS, implementation and design errors happens. Check the Computrace anti-theft rootkit for details.Hypervisor - Ring -1 rootkitThis is somewhat special, because I believe although rootkit can run in this layer but it can&#39;t persist only in this layer on an average, physical machine, because it won&#39;t survive a reboot See Rutkowska&#39;s presentation from 2006 But because the hypervisor can intercept the restart event, it can write itself into one of the other layers (e.g. install a common kernel driver), and simply delete it after it is fully functional after reboot. Update: There is a good paper from Igor Korkin about hypervisor detection here.SMM (System Management Mode) malware - Ring -2 rootkitSomehow related to the previous type of attacks, but not many people know that System Management Mode can be used to inject code into the OS. Check the DEITYBOUNCE malware for more details ;) Also, abusing Intel Dual Monitor Mode (DMM) can lead to untrusted code execution, which basically monitors the SMM mode.Intel® Active Management Technology - Ring -3 rootkitAccording to Wikipedia, &quot;Intel Active Management Technology (AMT) is hardware and firmware technology for remote out-of-band management of personal computers, in order to monitor, maintain, update, upgrade, and repair them&quot;. You can ask, what could possibly go wrong? See Alexander Tereshkin&#39;s and Rafal Wojtczuk&#39;s great research on this, or Vassilios Ververis thesis about AMT. As not many people click on links, let me quote the scary stuff about AMT:Independent of the main CPUCan access host memory via DMA (with restrictions)Dedicated link to NIC, and its filtering capabilitiesCan force host OS to reboot at any time (and boot the system from the emulated CDROM)Active even in S3 sleep!Other stuffCreate new user, update existing user, hidden adminsSometimes one does not even have to add malicious code to the system, as valid user credentials are more than enough. Either existing users can be used for this purpose, or new ones can be created. E.g. a good trick is to use the Support account with a 500 RID - see here, Metasploit tool here.Esoteric firmware malwareAlmost any component in the computer runs with firmware, and by replacing the firmware with a malicious one, it is possible to start the malware. E.g. HDD firmware (see GrayFish again), graphic card, etc.Hidden boot deviceMalware can hide in one of the boot devices which are checked before the average OS is loaded, and after the malware is loaded, it can load the victim OS.Network-level backdoorThink about the following scenario: every time the OS boots, it loads additional data from the network. It can check for new software updates, configuration updates, etc. Whenever a vulnerable software/configuration update, the malware injects itself into the response, and get&#39;s executed. I know, this level of persistence is not foolproof, but still, possible. Think about the recently discovered GPO MiTM attack, the Evilgrade tool, or even the Xensploit tool when we are talking about VM migration.Software vulnerabilityAlmost any kind of software vulnerability can be used as a persistent backdoor. Especially, if the vulnerability can be accessed remotely via the network, without any user interaction. Good old MS08-067...Hardware malware, built into the chipsetI am not sure what to write here. Ask your local spy agency for further information. Good luck finding those!More linksTools I highly recommend:Sysinternals AutorunsGMERDLL hijack detectorPCHunterMandiant RedlineVolatilityKansaFor more information, check this blog post, part 1, part 2Update 2017-04-29: A very nice list of Office persistence: https://labs.mwrinfosecurity.com/blog/add-in-opportunities-for-office-persistence/Update 2017-10-23: Persistence via Security Descriptors and ACLs: https://www.youtube.com/watch?v=SeR4QJbaNRgUpdate 2018-07-25: Backdooring LAPS https://rastamouse.me/2018/03/laps---part-1/https://rastamouse.me/2018/03/laps---part-2/ I would like to thank to Gabor Pek from CrySyS Lab for reviewing and completing this post." />
<meta property="og:description" content="TL;DR: Are you into red teaming? Need persistence? This post is not that long, read it ;) Are you into blue teaming? Have to find those pesky backdoors? This post is not that long, read it ;) In the previous post, I listed different ways how a Windows domain/forest can be backdoored. In this new post, I am digging a bit deeper, and list the most common/known ways malware can survive a reboot, just using local resources of the infected Windows system. The list is far from complete, and I would like to encourage everyone to comment on new methods, not yet listed here. From an incident response point of view, one of the best strategies to find malware on a suspicious system is to search for suspicious entries that start with the system. In the good old days, you had to check for 2-3 locations to cover 99% of the infections. Nowadays, there are a thousand ways malware can start. The common ones automatically start whenever Windows starts (or the user logs in), but some tricky ones are triggered by other events. AutorunsMy favorite choice when it comes to malware persistence is Sysinternals tools, Autoruns. In this paragraph, I mainly quote the official built-in help, but bear with me, it is still interesting.On a side note, there are some problems with the Autoruns tool: it can only run on a live system. (EDIT: This is not true, Autoruns can analyze offline systems as well! Thanks to a comment from Justin.) And usually, this is not the case - I usually have dd images. And although VBoxManage can convert the dd images to VirtualBox disk image format, usually I don&#39;t have the time and storage to do that. This is where xmount awesomeness is here to rescue the day. It can convert dd and Encase images on-the-fly in-memory to Virtualbox format. Just attach the disk image to a new Virtualbox machine as the main boot HDD, modify the CPU/disk/controller settings until Windows starts instead of crashing, and voila, you can boot your forensic image - without modifying a single bit on the original evidence dd file. Another problem with malware analysis on a live system is that a good rootkit can fool the analyst easily. For quick wins, I usually filter out Microsoft entries, look for per-user locations only and check for unverified (missing or invalid Authenticode) executables. This usually helps to find 90% of malware easily. Especially if it has a color like purple or pink, it is highly suspicious. To find the rest, well, one has to dig deeper.Zeus &quot;hiding&quot; in the usual random directory - check the faked timestampTo implement &quot;poor-mans monitoring&quot;, regularly save the output of Autoruns, and during incident response, it will be highly valuable. Howto guide here.Logon&quot;This entry results in scans of standard autostart locations such as the Startup folder for the current user and all users, the Run Registry keys, and standard application launch locations.&quot; There are 42 registry keys/folders at the moment in Autoruns, which can be used to autostart a malware. The most common ways are the HKCU\Software\Microsoft\Windows\CurrentVersion\Run and the C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup folder.One of my favorite regarding this topic is the file-less Poweliks malware, 100% pure awesomeness. Typical ring 3 code execution.Explorer&quot;Select this entry to see Explorer shell extensions, browser helper objects, explorer toolbars, active setup executions, and shell execute hooks&quot;. 71 registry keys, OMG. Usually, this is not about auto-malware execution, but some of them might be a good place to hide malware.Internet explorer&quot;This entry shows Browser Helper Objects (BHO&#39;s), Internet Explorer toolbars and extensions&quot;. 13 registry key here. If a malicious BHO is installed into your browser, you are pretty much screwed.Scheduled tasks&quot;Task scheduler tasks configured to start at boot or logon.&quot; Not commonly used, but it is important to look at this.I always thought this part of the autostart entries is quite boring, but nowadays, I think it is one of the best ways to hide your malware. There are so many entries here by default, and some of them can use quite good tricks to trigger the start.Did you know that you can create custom events that trigger on Windows event logs?Did you know you can create malware persistence just by using Windows tools like bitsadmin and Scheduled tasks?Scheduler in the old daysScheduler in the new daysServicesHKLM\System\CurrentControlSet\Services is a very commonplace to hide malware, especially rootkits. Check all entries with special care.DriversSame as services. Very commonplace for rootkits. Unfortunately, signing a driver for 64-bit systems is not fun anymore, as it has to be signed by certificates that can be chained back to &quot;Software Publisher Certificates&quot;. Typical startup place for Ring 0 rootkits. Starting from Windows 10, even this will change and all drivers have to be signed by &quot;Windows Hardware Developer Center Dashboard portal&quot; and EV certificates.Codecs22 registry keys. Not very common, but possible code execution.Boot execute&quot;Native images (as opposed to Windows images) that run early during the boot process.&quot;5 registry keys here. Good place to hide a rootkit here.Image hijacks&quot;Image file execution options and command prompt autostarts.&quot; 13 registry key here. I believe this was supposed for debugging purposes originally.This is where the good-old sticky keys trick is hiding. It is a bit different from the others, as it provides a backdoor access, but you can only use this from the local network (usually). The trick is to execute your code whenever someone presses the SHIFT key multiple times before logging into RDP. The old way was to replace the sethc.exe, the new fun is to set a debug program on sethc. If you see this, you are in troubleAppInit&quot;This has Autoruns shows DLLs registered as application initialization DLLs.&quot; Only 3 registry keys here. This is the good old way to inject a malicious DLL into Explorer, browsers, etc. Luckily it is going to be deprecated soon.Known DLLs&quot;This reports the location of DLLs that Windows loads into applications that reference them.&quot; Only 1 registry key. This might be used to hijack some system DLLs.Winlogon&quot;Shows DLLs that register for Winlogon notification of logon events.&quot; 7 registry keys. Sometimes used by malware.Winsock providers&quot;Shows registered Winsock protocols, including Winsock service providers. Malware often installs itself as a Winsock service provider because there are few tools that can remove them. Autoruns can disable them, but cannot delete them.&quot; 4 registry keys. AFAIK this was trendy a while ago. But still, a good place to hide malware.Print monitors&quot;Displays DLLs that load into the print spooling service. Malware has used this support to autostart itself.&quot; 1 registry key. Some malware writers are quite creative when it comes to hiding their persistence module.LSA providers&quot;Shows registers Local Security Authority (LSA) authentication, notification and security packages.&quot; 5 registry keys. A good place to hide your password stealer. Network providers&quot;Missing documentation&quot;. If you have a good 1 sentence documentation, please comment.WMI filters&quot;Missing documentation&quot;. Check Mandiant for details.Sidebar gadgetsThank god MS disabled this a while ago :)We all miss you, you crappy resource gobble nightmaresCommon ways - not in autorunsNow, let&#39;s see other possibilities to start your malware, which won&#39;t be listed in Sysinternals Autoruns.Backdoor an executable/DLLJust change the code of an executable which is either auto-starting or commonly started by the user. To avoid lame mistakes, disable the update of the file ... The backdoor factory is a good source for this task. But if you backdoor an executable/DLL which is already in Autoruns listed, you will break the Digital Signature on the file. It is recommended to sign your executable, and if you can&#39;t afford to steal a trusted certificate, you can still import your own CA into the user&#39;s trusted certificate store (with user privileges), and it will look like a trusted one. Protip: Use &quot;Microsoft Windows&quot; as the codesigner CA, and your executable will blend in.See, rootkit.exe totally looks legit, and it is filtered out when someone filters for &quot;Hide Windows entries&quot;.Hijack DLL load orderJust place your DLL into a directory which is searched before the original DLL is found, and PROFIT! But again, to avoid lame detection, be sure to proxy the legitimate function calls to the original DLL. A good source on this topic from Mandiant and DLL hijack detector.Here you can see how PlugX works in action, by dropping a legitimate Kaspersky executable, and hijacking the DLL calls with their DLL. Hijack a shortcut from the desktop/start menuNever underestimate the power of lame tricks. Just create an executable which calls the original executable, and meanwhile starts your backdoor. Replace the link, PROFIT! And don&#39;t be a skiddie, check the icon ;) I have seen this trick in adware hijacking browsers a lot of times.IE hijacked to start with http://tinyurl.com/2fcpre6File association hijackChoose the user&#39;s favorite file type, replace the program which handles the opening with a similar one described in the previous section, and voila!COM object hijackThe main idea is that some COM objects are scanned for whether they are on the system or not, and when it is registered, it is automatically loaded. See COMpfun for details.Windows Application Compatibility - SHIMNot many people are familiar with Windows Application Compatibility and how it works. Think about it as an added layer between applications and the OS. If the application matches a certain condition (e.g. filename), certain actions will take place. E.g. emulation of directories, registry entries, DLL injection, etc. In my installation, there are 367 different compatibility fixes (type of compatibility &quot;simulation&quot;), and some of those can be customized.Every time IE starts, inject a DLL into IEBootkits Although bootkits shown here can end up in Autoruns in the drivers section (as they might need a driver at the end of the day), I still think it deserves a different section.MBR - Master boot recordMalware can overwrite the Master boot record, start the boot process with its own code, and continue the boot process with the original one. It is common for rootkits to fake the content of the MBR record, and show the original contents. Which means one just have attached the infected HDD to a clean system, and compare the first 512 bytes (or more in some cases) with a known, clean state, or compare it to the contents shown from the infected OS. SecureBoot can be used to prevent malware infections like this.There is a slight difference when MBR is viewed from infected OS vs clean OSVBR - Volume boot recordThis is the next logical step where malware can start it&#39;s process, and some malware/rootkit prefers to hide it&#39;s startup code here. Check GrayFish for details. SecureBoot can be used to prevent malware infections like this.BIOS/UEFI malwareBoth the old BIOS and the new UEFI can be modified in a way that malware starts even before the OS had a chance to run. Although UEFI was meant to be more secure than BIOS, implementation and design errors happens. Check the Computrace anti-theft rootkit for details.Hypervisor - Ring -1 rootkitThis is somewhat special, because I believe although rootkit can run in this layer but it can&#39;t persist only in this layer on an average, physical machine, because it won&#39;t survive a reboot See Rutkowska&#39;s presentation from 2006 But because the hypervisor can intercept the restart event, it can write itself into one of the other layers (e.g. install a common kernel driver), and simply delete it after it is fully functional after reboot. Update: There is a good paper from Igor Korkin about hypervisor detection here.SMM (System Management Mode) malware - Ring -2 rootkitSomehow related to the previous type of attacks, but not many people know that System Management Mode can be used to inject code into the OS. Check the DEITYBOUNCE malware for more details ;) Also, abusing Intel Dual Monitor Mode (DMM) can lead to untrusted code execution, which basically monitors the SMM mode.Intel® Active Management Technology - Ring -3 rootkitAccording to Wikipedia, &quot;Intel Active Management Technology (AMT) is hardware and firmware technology for remote out-of-band management of personal computers, in order to monitor, maintain, update, upgrade, and repair them&quot;. You can ask, what could possibly go wrong? See Alexander Tereshkin&#39;s and Rafal Wojtczuk&#39;s great research on this, or Vassilios Ververis thesis about AMT. As not many people click on links, let me quote the scary stuff about AMT:Independent of the main CPUCan access host memory via DMA (with restrictions)Dedicated link to NIC, and its filtering capabilitiesCan force host OS to reboot at any time (and boot the system from the emulated CDROM)Active even in S3 sleep!Other stuffCreate new user, update existing user, hidden adminsSometimes one does not even have to add malicious code to the system, as valid user credentials are more than enough. Either existing users can be used for this purpose, or new ones can be created. E.g. a good trick is to use the Support account with a 500 RID - see here, Metasploit tool here.Esoteric firmware malwareAlmost any component in the computer runs with firmware, and by replacing the firmware with a malicious one, it is possible to start the malware. E.g. HDD firmware (see GrayFish again), graphic card, etc.Hidden boot deviceMalware can hide in one of the boot devices which are checked before the average OS is loaded, and after the malware is loaded, it can load the victim OS.Network-level backdoorThink about the following scenario: every time the OS boots, it loads additional data from the network. It can check for new software updates, configuration updates, etc. Whenever a vulnerable software/configuration update, the malware injects itself into the response, and get&#39;s executed. I know, this level of persistence is not foolproof, but still, possible. Think about the recently discovered GPO MiTM attack, the Evilgrade tool, or even the Xensploit tool when we are talking about VM migration.Software vulnerabilityAlmost any kind of software vulnerability can be used as a persistent backdoor. Especially, if the vulnerability can be accessed remotely via the network, without any user interaction. Good old MS08-067...Hardware malware, built into the chipsetI am not sure what to write here. Ask your local spy agency for further information. Good luck finding those!More linksTools I highly recommend:Sysinternals AutorunsGMERDLL hijack detectorPCHunterMandiant RedlineVolatilityKansaFor more information, check this blog post, part 1, part 2Update 2017-04-29: A very nice list of Office persistence: https://labs.mwrinfosecurity.com/blog/add-in-opportunities-for-office-persistence/Update 2017-10-23: Persistence via Security Descriptors and ACLs: https://www.youtube.com/watch?v=SeR4QJbaNRgUpdate 2018-07-25: Backdooring LAPS https://rastamouse.me/2018/03/laps---part-1/https://rastamouse.me/2018/03/laps---part-2/ I would like to thank to Gabor Pek from CrySyS Lab for reviewing and completing this post." />
<link rel="canonical" href="https://httpscolonforwardslashforwardslashwwwdotzoltanbalazsdotcom.com/malware/persistence/windows/2015/05/05/Many-ways-of-malware-persistence-(that-you-were-always-afraid-to-ask).html" />
<meta property="og:url" content="https://httpscolonforwardslashforwardslashwwwdotzoltanbalazsdotcom.com/malware/persistence/windows/2015/05/05/Many-ways-of-malware-persistence-(that-you-were-always-afraid-to-ask).html" />
<meta property="og:site_name" content="Jump ESP, jump!" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-05-05T13:39:39+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Many ways of malware persistence (that you were always afraid to ask)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2015-05-05T13:39:39+00:00","datePublished":"2015-05-05T13:39:39+00:00","description":"TL;DR: Are you into red teaming? Need persistence? This post is not that long, read it ;) Are you into blue teaming? Have to find those pesky backdoors? This post is not that long, read it ;) In the previous post, I listed different ways how a Windows domain/forest can be backdoored. In this new post, I am digging a bit deeper, and list the most common/known ways malware can survive a reboot, just using local resources of the infected Windows system. The list is far from complete, and I would like to encourage everyone to comment on new methods, not yet listed here. From an incident response point of view, one of the best strategies to find malware on a suspicious system is to search for suspicious entries that start with the system. In the good old days, you had to check for 2-3 locations to cover 99% of the infections. Nowadays, there are a thousand ways malware can start. The common ones automatically start whenever Windows starts (or the user logs in), but some tricky ones are triggered by other events. AutorunsMy favorite choice when it comes to malware persistence is Sysinternals tools, Autoruns. In this paragraph, I mainly quote the official built-in help, but bear with me, it is still interesting.On a side note, there are some problems with the Autoruns tool: it can only run on a live system. (EDIT: This is not true, Autoruns can analyze offline systems as well! Thanks to a comment from Justin.) And usually, this is not the case - I usually have dd images. And although VBoxManage can convert the dd images to VirtualBox disk image format, usually I don&#39;t have the time and storage to do that. This is where xmount awesomeness is here to rescue the day. It can convert dd and Encase images on-the-fly in-memory to Virtualbox format. Just attach the disk image to a new Virtualbox machine as the main boot HDD, modify the CPU/disk/controller settings until Windows starts instead of crashing, and voila, you can boot your forensic image - without modifying a single bit on the original evidence dd file. Another problem with malware analysis on a live system is that a good rootkit can fool the analyst easily. For quick wins, I usually filter out Microsoft entries, look for per-user locations only and check for unverified (missing or invalid Authenticode) executables. This usually helps to find 90% of malware easily. Especially if it has a color like purple or pink, it is highly suspicious. To find the rest, well, one has to dig deeper.Zeus &quot;hiding&quot; in the usual random directory - check the faked timestampTo implement &quot;poor-mans monitoring&quot;, regularly save the output of Autoruns, and during incident response, it will be highly valuable. Howto guide here.Logon&quot;This entry results in scans of standard autostart locations such as the Startup folder for the current user and all users, the Run Registry keys, and standard application launch locations.&quot; There are 42 registry keys/folders at the moment in Autoruns, which can be used to autostart a malware. The most common ways are the HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run and the C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup folder.One of my favorite regarding this topic is the file-less Poweliks malware, 100% pure awesomeness. Typical ring 3 code execution.Explorer&quot;Select this entry to see Explorer shell extensions, browser helper objects, explorer toolbars, active setup executions, and shell execute hooks&quot;. 71 registry keys, OMG. Usually, this is not about auto-malware execution, but some of them might be a good place to hide malware.Internet explorer&quot;This entry shows Browser Helper Objects (BHO&#39;s), Internet Explorer toolbars and extensions&quot;. 13 registry key here. If a malicious BHO is installed into your browser, you are pretty much screwed.Scheduled tasks&quot;Task scheduler tasks configured to start at boot or logon.&quot; Not commonly used, but it is important to look at this.I always thought this part of the autostart entries is quite boring, but nowadays, I think it is one of the best ways to hide your malware. There are so many entries here by default, and some of them can use quite good tricks to trigger the start.Did you know that you can create custom events that trigger on Windows event logs?Did you know you can create malware persistence just by using Windows tools like bitsadmin and Scheduled tasks?Scheduler in the old daysScheduler in the new daysServicesHKLM\\System\\CurrentControlSet\\Services is a very commonplace to hide malware, especially rootkits. Check all entries with special care.DriversSame as services. Very commonplace for rootkits. Unfortunately, signing a driver for 64-bit systems is not fun anymore, as it has to be signed by certificates that can be chained back to &quot;Software Publisher Certificates&quot;. Typical startup place for Ring 0 rootkits. Starting from Windows 10, even this will change and all drivers have to be signed by &quot;Windows Hardware Developer Center Dashboard portal&quot; and EV certificates.Codecs22 registry keys. Not very common, but possible code execution.Boot execute&quot;Native images (as opposed to Windows images) that run early during the boot process.&quot;5 registry keys here. Good place to hide a rootkit here.Image hijacks&quot;Image file execution options and command prompt autostarts.&quot; 13 registry key here. I believe this was supposed for debugging purposes originally.This is where the good-old sticky keys trick is hiding. It is a bit different from the others, as it provides a backdoor access, but you can only use this from the local network (usually). The trick is to execute your code whenever someone presses the SHIFT key multiple times before logging into RDP. The old way was to replace the sethc.exe, the new fun is to set a debug program on sethc. If you see this, you are in troubleAppInit&quot;This has Autoruns shows DLLs registered as application initialization DLLs.&quot; Only 3 registry keys here. This is the good old way to inject a malicious DLL into Explorer, browsers, etc. Luckily it is going to be deprecated soon.Known DLLs&quot;This reports the location of DLLs that Windows loads into applications that reference them.&quot; Only 1 registry key. This might be used to hijack some system DLLs.Winlogon&quot;Shows DLLs that register for Winlogon notification of logon events.&quot; 7 registry keys. Sometimes used by malware.Winsock providers&quot;Shows registered Winsock protocols, including Winsock service providers. Malware often installs itself as a Winsock service provider because there are few tools that can remove them. Autoruns can disable them, but cannot delete them.&quot; 4 registry keys. AFAIK this was trendy a while ago. But still, a good place to hide malware.Print monitors&quot;Displays DLLs that load into the print spooling service. Malware has used this support to autostart itself.&quot; 1 registry key. Some malware writers are quite creative when it comes to hiding their persistence module.LSA providers&quot;Shows registers Local Security Authority (LSA) authentication, notification and security packages.&quot; 5 registry keys. A good place to hide your password stealer. Network providers&quot;Missing documentation&quot;. If you have a good 1 sentence documentation, please comment.WMI filters&quot;Missing documentation&quot;. Check Mandiant for details.Sidebar gadgetsThank god MS disabled this a while ago :)We all miss you, you crappy resource gobble nightmaresCommon ways - not in autorunsNow, let&#39;s see other possibilities to start your malware, which won&#39;t be listed in Sysinternals Autoruns.Backdoor an executable/DLLJust change the code of an executable which is either auto-starting or commonly started by the user. To avoid lame mistakes, disable the update of the file ... The backdoor factory is a good source for this task. But if you backdoor an executable/DLL which is already in Autoruns listed, you will break the Digital Signature on the file. It is recommended to sign your executable, and if you can&#39;t afford to steal a trusted certificate, you can still import your own CA into the user&#39;s trusted certificate store (with user privileges), and it will look like a trusted one. Protip: Use &quot;Microsoft Windows&quot; as the codesigner CA, and your executable will blend in.See, rootkit.exe totally looks legit, and it is filtered out when someone filters for &quot;Hide Windows entries&quot;.Hijack DLL load orderJust place your DLL into a directory which is searched before the original DLL is found, and PROFIT! But again, to avoid lame detection, be sure to proxy the legitimate function calls to the original DLL. A good source on this topic from Mandiant and DLL hijack detector.Here you can see how PlugX works in action, by dropping a legitimate Kaspersky executable, and hijacking the DLL calls with their DLL. Hijack a shortcut from the desktop/start menuNever underestimate the power of lame tricks. Just create an executable which calls the original executable, and meanwhile starts your backdoor. Replace the link, PROFIT! And don&#39;t be a skiddie, check the icon ;) I have seen this trick in adware hijacking browsers a lot of times.IE hijacked to start with http://tinyurl.com/2fcpre6File association hijackChoose the user&#39;s favorite file type, replace the program which handles the opening with a similar one described in the previous section, and voila!COM object hijackThe main idea is that some COM objects are scanned for whether they are on the system or not, and when it is registered, it is automatically loaded. See COMpfun for details.Windows Application Compatibility - SHIMNot many people are familiar with Windows Application Compatibility and how it works. Think about it as an added layer between applications and the OS. If the application matches a certain condition (e.g. filename), certain actions will take place. E.g. emulation of directories, registry entries, DLL injection, etc. In my installation, there are 367 different compatibility fixes (type of compatibility &quot;simulation&quot;), and some of those can be customized.Every time IE starts, inject a DLL into IEBootkits Although bootkits shown here can end up in Autoruns in the drivers section (as they might need a driver at the end of the day), I still think it deserves a different section.MBR - Master boot recordMalware can overwrite the Master boot record, start the boot process with its own code, and continue the boot process with the original one. It is common for rootkits to fake the content of the MBR record, and show the original contents. Which means one just have attached the infected HDD to a clean system, and compare the first 512 bytes (or more in some cases) with a known, clean state, or compare it to the contents shown from the infected OS. SecureBoot can be used to prevent malware infections like this.There is a slight difference when MBR is viewed from infected OS vs clean OSVBR - Volume boot recordThis is the next logical step where malware can start it&#39;s process, and some malware/rootkit prefers to hide it&#39;s startup code here. Check GrayFish for details. SecureBoot can be used to prevent malware infections like this.BIOS/UEFI malwareBoth the old BIOS and the new UEFI can be modified in a way that malware starts even before the OS had a chance to run. Although UEFI was meant to be more secure than BIOS, implementation and design errors happens. Check the Computrace anti-theft rootkit for details.Hypervisor - Ring -1 rootkitThis is somewhat special, because I believe although rootkit can run in this layer but it can&#39;t persist only in this layer on an average, physical machine, because it won&#39;t survive a reboot See Rutkowska&#39;s presentation from 2006 But because the hypervisor can intercept the restart event, it can write itself into one of the other layers (e.g. install a common kernel driver), and simply delete it after it is fully functional after reboot. Update: There is a good paper from Igor Korkin about hypervisor detection here.SMM (System Management Mode) malware - Ring -2 rootkitSomehow related to the previous type of attacks, but not many people know that System Management Mode can be used to inject code into the OS. Check the DEITYBOUNCE malware for more details ;) Also, abusing Intel Dual Monitor Mode (DMM) can lead to untrusted code execution, which basically monitors the SMM mode.Intel® Active Management Technology - Ring -3 rootkitAccording to Wikipedia, &quot;Intel Active Management Technology (AMT) is hardware and firmware technology for remote out-of-band management of personal computers, in order to monitor, maintain, update, upgrade, and repair them&quot;. You can ask, what could possibly go wrong? See Alexander Tereshkin&#39;s and Rafal Wojtczuk&#39;s great research on this, or Vassilios Ververis thesis about AMT. As not many people click on links, let me quote the scary stuff about AMT:Independent of the main CPUCan access host memory via DMA (with restrictions)Dedicated link to NIC, and its filtering capabilitiesCan force host OS to reboot at any time (and boot the system from the emulated CDROM)Active even in S3 sleep!Other stuffCreate new user, update existing user, hidden adminsSometimes one does not even have to add malicious code to the system, as valid user credentials are more than enough. Either existing users can be used for this purpose, or new ones can be created. E.g. a good trick is to use the Support account with a 500 RID - see here, Metasploit tool here.Esoteric firmware malwareAlmost any component in the computer runs with firmware, and by replacing the firmware with a malicious one, it is possible to start the malware. E.g. HDD firmware (see GrayFish again), graphic card, etc.Hidden boot deviceMalware can hide in one of the boot devices which are checked before the average OS is loaded, and after the malware is loaded, it can load the victim OS.Network-level backdoorThink about the following scenario: every time the OS boots, it loads additional data from the network. It can check for new software updates, configuration updates, etc. Whenever a vulnerable software/configuration update, the malware injects itself into the response, and get&#39;s executed. I know, this level of persistence is not foolproof, but still, possible. Think about the recently discovered GPO MiTM attack, the Evilgrade tool, or even the Xensploit tool when we are talking about VM migration.Software vulnerabilityAlmost any kind of software vulnerability can be used as a persistent backdoor. Especially, if the vulnerability can be accessed remotely via the network, without any user interaction. Good old MS08-067...Hardware malware, built into the chipsetI am not sure what to write here. Ask your local spy agency for further information. Good luck finding those!More linksTools I highly recommend:Sysinternals AutorunsGMERDLL hijack detectorPCHunterMandiant RedlineVolatilityKansaFor more information, check this blog post, part 1, part 2Update 2017-04-29: A very nice list of Office persistence: https://labs.mwrinfosecurity.com/blog/add-in-opportunities-for-office-persistence/Update 2017-10-23: Persistence via Security Descriptors and ACLs: https://www.youtube.com/watch?v=SeR4QJbaNRgUpdate 2018-07-25: Backdooring LAPS https://rastamouse.me/2018/03/laps---part-1/https://rastamouse.me/2018/03/laps---part-2/ I would like to thank to Gabor Pek from CrySyS Lab for reviewing and completing this post.","headline":"Many ways of malware persistence (that you were always afraid to ask)","mainEntityOfPage":{"@type":"WebPage","@id":"https://httpscolonforwardslashforwardslashwwwdotzoltanbalazsdotcom.com/malware/persistence/windows/2015/05/05/Many-ways-of-malware-persistence-(that-you-were-always-afraid-to-ask).html"},"url":"https://httpscolonforwardslashforwardslashwwwdotzoltanbalazsdotcom.com/malware/persistence/windows/2015/05/05/Many-ways-of-malware-persistence-(that-you-were-always-afraid-to-ask).html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css">
  <link rel="icon" type="image/png" href="/assets/favicon.png" />
  <link rel="stylesheet" href="/assets/css/magnific-popup.css"><link type="application/atom+xml" rel="alternate" href="https://httpscolonforwardslashforwardslashwwwdotzoltanbalazsdotcom.com/feed.xml" title="Jump ESP, jump!" /><script src="https://code.jquery.com/jquery-3.2.0.min.js"></script> 
  <script src="/assets/js/jquery.magnific-popup.js"></script>
</head>
<body><div class="site-header">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Jump ESP, jump!<b class="command_prompt"></b><b class="blinking_cursor">_</b></a>
    <span class="social_links">
        
    </span>
  </div>
</div>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        
  <div class="author-box">


<img src="
    https://gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?s=256
" class="author-avatar" alt="Avatar" />
<div class="description">Because Google started to delete hacking related blog posts  without using a single brain cell, I had to learn just another framework. Thx Google </div>

</div>


<div class="post">
  <h1 class="post-title">Many ways of malware persistence (that you were always afraid to ask)</h1>
  
  <div class="post-tags">
      
  </div>
  
  <div class="post-date">
    Published on 05 May 2015
    
  </div>
  
  <div style="">TL;DR: Are you into red teaming? Need persistence? This post is not that long, read it ;)</div>
<div style="">Are you into blue teaming? Have to find those pesky backdoors? This post is not that long, read it ;)</div>
<div style=""><br /></div>
<div style="">In the <a href="http://jumpespjump.blogspot.com/2015/03/thousand-ways-to-backdoor-windows.html" target="_blank">previous post</a>, I listed different ways how a Windows domain/forest can be backdoored. In this new post, I am digging a bit deeper, and list the most common/known ways malware can survive a reboot, just using local resources of the infected Windows system. The list is far from complete, and I would like to encourage everyone to comment on new methods, not yet listed here. </div>
<div style=""><br /></div>
<div style="">From an incident response point of view, one of the best strategies to find malware on a suspicious system is to search for suspicious entries that start with the system. In the good old days, you had to check for 2-3 locations to cover 99% of the infections. Nowadays, there are a thousand ways malware can start. The common ones automatically start whenever Windows starts (or the user logs in), but some tricky ones are triggered by other events.</div>
<div style=""><br /></div>
<div><h2 style="text-align: justify;">Autoruns</h2><div><div style="">My favorite choice when it comes to malware persistence is Sysinternals tools, Autoruns. In this paragraph, I mainly quote the official built-in help, but bear with me, it is still interesting.</div><div style=""><br /></div><div style="">On a side note, there are some problems with the Autoruns tool: it can only run on a live system. (EDIT: This is not true, Autoruns can analyze offline systems as well! Thanks to a comment from Justin.) And usually, this is not the case - I usually have dd images. And although VBoxManage can convert the dd images to VirtualBox disk image format, usually I don't have the time and storage to do that. This is where xmount awesomeness is here to rescue the day. It can convert dd and Encase images on-the-fly in-memory to Virtualbox format. Just attach the disk image to a new Virtualbox machine as the main boot HDD, modify the CPU/disk/controller settings until Windows starts instead of crashing, and voila, you can boot your forensic image - without modifying a single bit on the original evidence dd file. Another problem with malware analysis on a live system is that a good rootkit can fool the analyst easily. </div><div style=""><br /></div><div style="">For quick wins, I usually filter out Microsoft entries, look for per-user locations only and check for unverified (missing or invalid Authenticode) executables. This usually helps to find 90% of malware easily. Especially if it has a color like purple or pink, it is highly suspicious. To find the rest, well, one has to dig deeper.</div><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://z6543.github.io/_img/zeus1.png" imageanchor="1" src="https://z6543.github.io/_img/zeus1.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="" src="https://z6543.github.io/_img/zeus1.png" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Zeus "hiding" in the usual random directory - check the faked timestamp</td></tr></tbody></table><div style="">To implement "poor-mans monitoring", regularly save the output of Autoruns, and during incident response, it will be highly valuable. Howto guide <a href="http://www.sans.org/reading-room/whitepapers/malicious/utilizing-autoruns-catch-malware-33383" target="_blank">here</a>.<br /><br /></div></div><h3></h3><h3></h3><h3 style="text-align: justify;">Logon</h3><div><div style="">"This entry results in scans of standard autostart locations such as the Startup  folder for the current user and all users, the Run Registry keys, and standard  application launch locations." </div></div><div><div style="">There are 42 registry keys/folders at the moment in Autoruns, which can be used to autostart a malware. The most common ways are the HKCU\Software\Microsoft\Windows\CurrentVersion\Run and the C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup folder.</div><div style="">One of my favorite regarding this topic is the <a href="https://blog.gdatasoftware.com/blog/article/poweliks-the-persistent-malware-without-a-file.html" target="_blank">file-less Poweliks malware</a>, 100% pure awesomeness. Typical ring 3 code execution.<br /><br /></div></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Explorer</h3><div><div style="">"Select this entry to see Explorer shell extensions, browser helper objects, explorer toolbars, active setup executions, and shell execute hooks". 71 registry keys, OMG. Usually, this is not about auto-malware execution, but some of them might be a good place to hide malware.<br /><br /></div></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Internet explorer</h3><div><div style="">"This entry shows Browser Helper Objects (BHO's), Internet Explorer toolbars and extensions". 13 registry key here. If a malicious BHO is installed into your browser, you are pretty much screwed.</div><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><img align="middle" border="0" height="300" src="https://z6543.github.io/_img/IE_pwn3d.jpg" width="400" /></td></tr></tbody></table><div style=""><br /></div></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Scheduled tasks</h3><div class="separator" style=""></div><div><div style="">"Task scheduler tasks configured to start at boot or logon." Not commonly used, but it is important to look at this.</div><div style="">I always thought this part of the autostart entries is quite boring, but nowadays, I think it is one of the best ways to hide your malware. There are so many entries here by default, and some of them can use quite good tricks to trigger the start.</div><div style="">Did you know that you can create custom events that <a href="http://blakhal0.blogspot.com/2015/03/windows-event-log-driven-back-doors.html" target="_blank">trigger on Windows event logs</a>?</div><div style="">Did you know you can create <a href="http://0xthem.blogspot.com/2014/03/t-emporal-persistence-with-and-schtasks.html" target="_blank">malware persistence just by using Windows tools</a> like bitsadmin and Scheduled tasks?</div><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://z6543.github.io/_img/sched2.png" imageanchor="1" src="https://z6543.github.io/_img/sched2.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="" src="https://z6543.github.io/_img/sched2.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Scheduler in the old days</td></tr></tbody></table><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://z6543.github.io/_img/sched.png" imageanchor="1" src="https://z6543.github.io/_img/sched.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="" src="https://z6543.github.io/_img/sched.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Scheduler in the new days</td></tr></tbody></table><div style=""><br /></div></div><h3></h3><h3></h3><h3 style="text-align: justify;">Services</h3><div><div style="">HKLM\System\CurrentControlSet\Services<span class="Apple-tab-span" style="white-space: pre;"> </span>is a very commonplace to hide malware, especially rootkits. Check all entries with special care.<br /><br /></div></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Drivers</h3><div><div style="">Same as services. Very commonplace for rootkits. Unfortunately, signing a driver for 64-bit systems is not fun anymore, as it has to be signed by certificates that can be chained back to "<a href="https://msdn.microsoft.com/en-us/library/windows/hardware/dn170454(v=vs.85).aspx" target="_blank">Software Publisher Certificates</a>". Typical startup place for Ring 0 rootkits. </div><div style="">Starting from Windows 10, even this will change and all drivers have to be signed by "<a href="http://blogs.msdn.com/b/windows_hardware_certification/archive/2015/04/01/driver-signing-changes-in-windows-10.aspx" target="_blank">Windows Hardware Developer Center Dashboard portal</a>" and EV certificates.<br /><br /></div></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Codecs</h3><div><div style="">22 registry keys. Not very common, but possible code execution.<br /><br /></div></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Boot execute</h3><div style="">"Native images (as opposed to Windows images) that run early during the boot process."</div><div style="">5 registry keys here. Good place to hide a rootkit here.<br /><br /></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Image hijacks</h3><div style="">"Image file execution options and command prompt autostarts." 13 registry key here. I believe this was supposed for debugging purposes originally.</div><div style="">This is where the good-old sticky keys trick is hiding. It is a bit different from the others, as it provides a backdoor access, but you can only use this from the local network (usually). The trick is to execute your code whenever someone presses the SHIFT key multiple times before logging into RDP. The old way was to replace the sethc.exe, the new fun is to <a href="http://www.labofapenetrationtester.com/2012/05/fun-with-sticky-keys-utilman-and.html" target="_blank">set a debug program on sethc</a>. </div><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://z6543.github.io/_img/sethc.png" imageanchor="1" src="https://z6543.github.io/_img/sethc.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="" src="https://z6543.github.io/_img/sethc.png" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">If you see this, you are in trouble</td></tr></tbody></table><div style=""><br /></div><h3></h3><h3></h3><h3 style="text-align: justify;">AppInit</h3><div style="">"This has Autoruns shows DLLs registered as application initialization DLLs." Only 3 registry keys here. This is the good old way to inject a malicious DLL into Explorer, browsers, etc. Luckily it is going to be deprecated soon.<br /><br /></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Known DLLs</h3><div style="">"This reports the location of DLLs that Windows loads into applications that reference them." Only 1 registry key. This might be used to hijack some system DLLs.<br /><br /></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Winlogon</h3><div style="">"Shows DLLs that register for Winlogon notification of logon events." 7 registry keys. Sometimes used by malware.<br /><br /></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Winsock providers</h3><div style="">"Shows registered Winsock protocols, including Winsock service providers. Malware often installs itself as a Winsock service provider because there are few tools that can remove them. Autoruns can disable them, but cannot delete them." 4 registry keys. AFAIK this was trendy a while ago. But still, a good place to hide malware.<br /><br /></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Print monitors</h3><div><div style="">"Displays DLLs that load into the print spooling service. Malware has used this support to autostart itself." 1 registry key. Some malware writers are quite creative when it comes to hiding their persistence module.<br /><br /></div></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">LSA providers</h3><div><div style="">"Shows registers Local Security Authority (LSA) authentication, notification and security packages." 5 registry keys. A good place to hide your password stealer. <br /><br /></div></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Network providers</h3><div><div style="">"Missing documentation". If you have a good 1 sentence documentation, please comment.<br /><br /></div></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">WMI filters</h3><div><div style="">"Missing documentation". Check <a href="https://dl.mandiant.com/EE/library/MIRcon2014/MIRcon_2014_IR_Track_There's_Something_About_WMI.pdf" target="_blank">Mandiant </a>for details.<br /><br /></div></div><h3></h3><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Sidebar gadgets</h3><div><div style="">Thank god MS disabled this a while ago :)</div><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://z6543.github.io/_img/coolest-best-latest-new-fun-tech-gadgets-sidebar-gadgets-2.jpg" imageanchor="1" src="https://z6543.github.io/_img/coolest-best-latest-new-fun-tech-gadgets-sidebar-gadgets-2.jpg" style="margin-left: auto; margin-right: auto;"><img border="0" height="" src="https://z6543.github.io/_img/coolest-best-latest-new-fun-tech-gadgets-sidebar-gadgets-2.jpg" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">We all miss you, you crappy resource gobble nightmares</td></tr></tbody></table><div style=""><br /></div></div><h2></h2><h2></h2><h2 style="text-align: justify;">Common ways - not in autoruns</h2><div><div style="">Now, let's see other possibilities to start your malware, which won't be listed in Sysinternals Autoruns.<br /><br /></div><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Backdoor an executable/DLL</h3></div><div><div style="">Just change the code of an executable which is either auto-starting or commonly started by the user. To avoid lame mistakes, disable the update of the file ... <a href="https://github.com/secretsquirrel/the-backdoor-factory" target="_blank">The backdoor factory</a> is a good source for this task. But if you backdoor an executable/DLL which is already in Autoruns listed, you will break the Digital Signature on the file. It is recommended to sign your executable, and if you can't afford to steal a trusted certificate, you can still import your own CA into the user's trusted certificate store (with user privileges), and it will look like a trusted one. Protip: Use "Microsoft Windows" as the codesigner CA, and your executable will blend in.</div><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://z6543.github.io/_img/cert3.png" imageanchor="1" src="https://z6543.github.io/_img/cert3.png" style="margin-left: 1em; margin-right: 1em;"><img align="middle" border="0" height="" src="https://z6543.github.io/_img/cert3.png" width="320" /></a></td></tr><tr><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"><a href="https://z6543.github.io/_img/certs.png" imageanchor="1" src="https://z6543.github.io/_img/certs.png" style="margin-left: 1em; margin-right: 1em;"><img align="middle" border="0" height="" src="https://z6543.github.io/_img/certs.png" width="318" /></a></td></tr><tr><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"><a href="https://z6543.github.io/_img/cert2.png" imageanchor="1" src="https://z6543.github.io/_img/cert2.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="" src="https://z6543.github.io/_img/cert2.png" width="640" /></a></td></tr></tbody></table>See, rootkit.exe totally looks legit, and it is filtered out when someone filters for "Hide Windows entries".<br /><br /><div><div style=""><span style="background-color: yellow;"><br /></span></div></div><div><h3></h3><h3 style="text-align: justify;">Hijack DLL load order</h3></div><div><div style="">Just place your DLL into a directory which is searched before the original DLL is found, and PROFIT! But again, to avoid lame detection, be sure to proxy the legitimate function calls to the original DLL. A good source on this topic from <a href="https://www.mandiant.com/blog/dll-search-order-hijacking-revisited/" target="_blank">Mandiant</a> and <a href="http://digital-forensics.sans.org/blog/2015/03/25/detecting-dll-hijacking-on-windows/" target="_blank">DLL hijack detector</a>.<br /><br /></div><div class="separator" style=""></div><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://z6543.github.io/_img/dll-hijack-detector.jpg" imageanchor="1" src="https://z6543.github.io/_img/dll-hijack-detector.jpg" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="" src="https://z6543.github.io/_img/dll-hijack-detector.jpg" width="400" /></a></td></tr></tbody></table><br />Here you can see how PlugX works in action, by dropping a legitimate Kaspersky executable, and hijacking the DLL calls with their DLL. </div><div class="separator" style=""><a href="https://z6543.github.io/_img/Screen2BShot2B2017-07-052Bat2B20.22.14.png" imageanchor="1" src="https://z6543.github.io/_img/Screen2BShot2B2017-07-052Bat2B20.22.14.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="635" data-original-width="1405" height="" src="https://z6543.github.io/_img/Screen2BShot2B2017-07-052Bat2B20.22.14.png" width="640" /></a></div><div><div style=""><br /></div></div><div><h3></h3><h3 style="text-align: justify;">Hijack a shortcut from the desktop/start menu</h3><div style="">Never underestimate the power of lame tricks. Just create an executable which calls the original executable, and meanwhile starts your backdoor. Replace the link, PROFIT! And don't be a skiddie, check the icon ;) I have seen this trick in adware hijacking browsers a lot of times.<br /><br /></div><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://z6543.github.io/_img/ie.png" imageanchor="1" src="https://z6543.github.io/_img/ie.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="" src="https://z6543.github.io/_img/ie.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">IE hijacked to start with http://tinyurl.com/2fcpre6</td></tr></tbody></table><div style=""><br /></div><h3></h3><h3></h3><h3 style="text-align: justify;">File association hijack</h3></div><div><div style="">Choose the user's favorite file type, replace the program which handles the opening with a similar one described in the previous section, and voila!</div><div style=""><br /></div></div><h3></h3><h3 style="text-align: justify;">COM object hijack</h3><div style="">The main idea is that some COM objects are scanned for whether they are on the system or not, and when it is registered, it is automatically loaded. See <a href="https://blog.gdatasoftware.com/blog/article/com-object-hijacking-the-discreet-way-of-persistence.html" target="_blank">COMpfun</a> for details.</div><div style=""><br /></div><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Windows Application Compatibility - SHIM</h3><div style="">Not many people are familiar with Windows Application Compatibility and how it works. Think about it as an added layer between applications and the OS. If the application matches a certain condition (e.g. filename), certain actions will take place. E.g. emulation of directories, registry entries, DLL injection, etc. In my installation, there are 367 different compatibility fixes (type of compatibility "simulation"), and some of those can be customized.</div><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://z6543.github.io/_img/sdb.png" imageanchor="1" src="https://z6543.github.io/_img/sdb.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="" src="https://z6543.github.io/_img/sdb.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Every time IE starts, inject a DLL into IE</td></tr></tbody></table><div style=""><br /></div><h2 style="text-align: justify;">Bootkits </h2><div><div style="">Although bootkits shown here can end up in Autoruns in the drivers section (as they might need a driver at the end of the day), I still think it deserves a different section.<br /><br /></div></div><div><h3 style="text-align: justify;">MBR - Master boot record</h3><div style="">Malware can overwrite the Master boot record, start the boot process with its own code, and continue the boot process with the original one. It is common for rootkits to fake the content of the MBR record, and show the original contents. Which means one just have attached the infected HDD to a clean system, and compare the first 512 bytes (or more in some cases) with a known, clean state, or compare it to the contents shown from the infected OS. SecureBoot can be used to prevent malware infections like this.</div></div><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td><a href="https://z6543.github.io/_img/mbr.png" imageanchor="1" src="https://z6543.github.io/_img/mbr.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="" src="https://z6543.github.io/_img/mbr.png" width="640" /></a></td></tr><tr><td class="tr-caption" style="font-size: 13px;">There is a slight difference when MBR is viewed from infected OS vs clean OS</td></tr></tbody></table><h3 style="text-align: justify;">VBR - Volume boot record</h3><div style="">This is the next logical step where malware can start it's process, and some malware/rootkit prefers to hide it's startup code here. Check <a href="http://arstechnica.com/security/2015/02/how-omnipotent-hackers-tied-to-the-nsa-hid-for-14-years-and-were-found-at-last/1/" target="_blank">GrayFish </a>for details. SecureBoot can be used to prevent malware infections like this.<br /><br /></div><h3 style="text-align: justify;">BIOS/UEFI malware</h3><div><div style="">Both the old BIOS and the new UEFI can be modified in a way that malware starts even before the OS had a chance to run. Although UEFI was meant to be more secure than BIOS, implementation and design errors happens. Check the<a href="http://securelist.com/analysis/publications/58278/absolute-computrace-revisited/" target="_blank"> Computrace anti-theft rootkit</a> for details.<br /><br /></div><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Hypervisor - Ring -1 rootkit</h3></div><h3></h3><div style="">This is somewhat special, because I believe although rootkit can run in this layer but it can't persist only in this layer on an average, physical machine, because it won't survive a reboot <a href="http://blackhat.com/presentations/bh-usa-06/BH-US-06-Rutkowska.pdf" target="_blank">See Rutkowska's presentation from 2006</a> But because the hypervisor can intercept the restart event, it can write itself into one of the other layers (e.g. install a common kernel driver), and simply delete it after it is fully functional after reboot. Update: There is a good paper from Igor Korkin about hypervisor detection <a href="http://igorkorkin.blogspot.ru/2015/05/two-challenges-of-stealthy-hypervisors.html" target="_blank">here</a>.<br /><br /></div><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">SMM (System Management Mode) malware - Ring -2 rootkit</h3><div><div style="">Somehow related to the previous type of attacks, but not many people know that <a href="http://en.wikipedia.org/wiki/System_Management_Mode#Problems" target="_blank">System Management Mode can be used to inject code into the OS</a>. Check the DEITYBOUNCE malware for more details ;) Also, abusing <a href="https://www.acsac.org/2014/workshops/mmf/Tamas%20Lengyel-Pitfalls%20of%20virtual%20machine%20introspection%20on%20modern%20hardware.pdf" target="_blank">Intel Dual Monitor Mode (DMM)</a> can lead to untrusted code execution, which basically monitors the SMM mode.</div><div style=""><br /></div><h3></h3><h3 style="text-align: justify;">Intel® Active Management Technology - Ring -3 rootkit</h3></div><div><div style="">According to Wikipedia, "Intel Active Management Technology (AMT) is hardware and firmware technology for remote out-of-band management of personal computers, in order to monitor, maintain, update, upgrade, and repair them". You can ask, what could possibly go wrong? See <a href="http://invisiblethingslab.com/resources/bh09usa/Ring%20-3%20Rootkits.pdf" target="_blank">Alexander Tereshkin's and Rafal Wojtczuk's great research</a> on this, or <a href="http://people.kth.se/~maguire/DEGREE-PROJECT-REPORTS/100402-Vassilios_Ververis-with-cover.pdf" target="_blank">Vassilios Ververis thesis about AMT</a>. </div><div style="">As not many people click on links, let me quote the scary stuff about AMT:</div></div></div><div><div><ul><li style="text-align: justify;">Independent of the main CPU</li><li style="text-align: justify;">Can access host memory via DMA (with restrictions)</li><li style="text-align: justify;">Dedicated link to NIC, and its filtering capabilities</li><li style="text-align: justify;">Can force host OS to reboot at any time (and boot the system from the emulated CDROM)</li><li style="text-align: justify;">Active even in S3 sleep!</li></ul></div><div><div style=""><br /></div><h2></h2><h2 style="text-align: justify;">Other stuff</h2><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Create new user, update existing user, hidden admins</h3></div><div><div style="">Sometimes one does not even have to add malicious code to the system, as valid user credentials are more than enough. Either existing users can be used for this purpose, or new ones can be created. E.g. a good trick is to use the Support account with a 500 RID - see <a href="http://xangosec.blogspot.com/2013/06/trojanizing-windows.html" target="_blank">here</a>, Metasploit tool <a href="https://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/manage/enable_support_account.rb" target="_blank">here</a>.<br /><br /></div></div><h3></h3><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Esoteric firmware malware</h3><div style="">Almost any component in the computer runs with firmware, and by replacing the firmware with a malicious one, it is possible to start the malware. E.g. HDD firmware (see <a href="http://arstechnica.com/security/2015/02/how-omnipotent-hackers-tied-to-the-nsa-hid-for-14-years-and-were-found-at-last/1/" target="_blank">GrayFish </a>again), graphic card, etc.<br /><br /></div><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Hidden boot device</h3><div style="">Malware can hide in one of the boot devices which are checked before the average OS is loaded, and after the malware is loaded, it can load the victim OS.<br /><br /></div><h3 style="text-align: justify;"></h3><h3>Network-level backdoor</h3><div style="">Think about the following scenario: every time the OS boots, it loads additional data from the network. It can check for new software updates, configuration updates, etc. Whenever a vulnerable software/configuration update, the malware injects itself into the response, and get's executed. I know, this level of persistence is not foolproof, but still, possible. Think about the recently discovered <a href="https://labs.mwrinfosecurity.com/blog/2015/04/02/how-to-own-any-windows-network-with-group-policy-hijacking-attacks/" target="_blank">GPO MiTM attack</a>, the <a href="https://github.com/infobyte/evilgrade" target="_blank">Evilgrade</a> tool, or even the <a href="https://www.blackhat.com/presentations/bh-dc-08/Oberheide/Whitepaper/bh-dc-08-oberheide-WP.pdf" target="_blank">Xensploit</a> tool when we are talking about VM migration.<br /><br /></div><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">Software vulnerability</h3><div style="">Almost any kind of software vulnerability can be used as a persistent backdoor. Especially, if the vulnerability can be accessed remotely via the network, without any user interaction. Good old MS08-067...<br /><br /></div><h3></h3><h3 style="text-align: justify;">Hardware malware, built into the chipset</h3><div style="">I am not sure what to write here. Ask your local spy agency for further information. Good luck finding those!<br /><br /></div><h3 style="text-align: justify;"></h3><h3 style="text-align: justify;">More links</h3><div>Tools I highly recommend:</div><div><ul><li><a href="https://technet.microsoft.com/en-us/sysinternals/bb545027.aspx" target="_blank">Sysinternals Autoruns</a></li><li><a href="http://www.gmer.net/" target="_blank">GMER</a></li><li><a href="http://digital-forensics.sans.org/blog/2015/03/25/detecting-dll-hijacking-on-windows/" target="_blank">DLL hijack detector</a></li><li>PCHunter</li><li><a href="https://www.mandiant.com/resources/download/redline" target="_blank">Mandiant Redline</a></li><li><a href="https://github.com/volatilityfoundation" target="_blank">Volatility</a></li><li><a href="https://github.com/davehull/Kansa/" target="_blank">Kansa</a></li></ul></div><div style="">For more information, check this blog post, <a href="http://blog.cylance.com/windows-registry-persistence-part-1-introduction-attack-phases-and-windows-services" target="_blank">part 1</a>, <a href="http://blog.cylance.com/windows-registry-persistence-part-2-the-run-keys-and-search-order" target="_blank">part 2</a><br /><br />Update 2017-04-29: A very nice list of Office persistence: <a href="https://labs.mwrinfosecurity.com/blog/add-in-opportunities-for-office-persistence/">https://labs.mwrinfosecurity.com/blog/add-in-opportunities-for-office-persistence/</a><br /><br />Update 2017-10-23: Persistence via Security Descriptors and ACLs: <a href="https://www.youtube.com/watch?v=SeR4QJbaNRg">https://www.youtube.com/watch?v=SeR4QJbaNRg</a><br /><br />Update 2018-07-25: Backdooring LAPS <a href="https://rastamouse.me/2018/03/laps---part-1/">https://rastamouse.me/2018/03/laps---part-1/</a><br /><a href="https://rastamouse.me/2018/03/laps---part-2/" target="_blank">https://rastamouse.me/2018/03/laps---part-2/ </a><br /><br />I would like to thank to Gabor Pek from CrySyS Lab for reviewing and completing this post.</div></div></div>

</div>





<div class="related">
  <h2>related posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2024/03/01/VPN-Snakeoil.html">
            Personal VPN services are snake-oil
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2023/04/05/Just_use_Jekyll.html">
            "Just" migrate to Jekyll ...
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2022/09/16/Google.html">
            So Long Google, and Thanks for All the Fish
          </a>
        </h3>
      </li>
    
  </ul>
</div>




  




<script>
  let i = 0;
  const text = '';
  const speed = parseInt('50');
  
  function typeWriter() {
    if (i < text.length) {
      document.getElementById('animated-post-description').innerHTML += text.charAt(i);
      i++;
      setTimeout(typeWriter, speed);
    }
  }

  document.getElementById('animated-post-description').style.display = 'initial';
  typeWriter();

  // Image modal
  var $imgs = [];
  $('img').each(function(idx) {
    var obj = {
      src: $(this).attr('src')
    }
    $imgs.push(obj);
    var elem = $(this);
    $(this).click(function() {
      $('.modal').magnificPopup('open', idx);
    });
  });

  $('.modal').magnificPopup({
    items: $imgs,
    type: 'image',
    closeOnContentClick: true,
    mainClass: 'mfp-img-mobile',
    image: {
      verticalFit: true
    }
    
  });
</script>

      </div>
    </main><footer class="site-footer">
  <div class="wrapper">
    <div class="credits"><a href="https://github.com/bitbrain/jekyll-dash">dash</a> theme for Jekyll by <a href="https://github.com/bitbrain">bitbrain</a> made with <i class="fas fa-heart"></i><div class="toggleWrapper">
    <input type="checkbox" class="dn" id="theme-toggle" onclick="modeSwitcher()" checked />
    <label for="theme-toggle" class="toggle">
    <span class="toggle__handler">
      <span class="crater crater--1"></span>
      <span class="crater crater--2"></span>
      <span class="crater crater--3"></span>
    </span>
        <span class="star star--1"></span>
        <span class="star star--2"></span>
        <span class="star star--3"></span>
        <span class="star star--4"></span>
        <span class="star star--5"></span>
        <span class="star star--6"></span>
    </label>
</div>
<script type="text/javascript">
const theme = localStorage.getItem('theme');

if (theme === "light") {
    document.documentElement.setAttribute('data-theme', 'light');
} else {
    document.documentElement.setAttribute('data-theme', 'dark');
}
const userPrefers = getComputedStyle(document.documentElement).getPropertyValue('content');

function activateDarkTheme() {
    document.getElementById('theme-toggle').checked = true;
    document.documentElement.setAttribute('data-theme', 'dark');
    document.documentElement.classList.add('theme--dark');
    document.documentElement.classList.remove('theme--light');
	document.getElementById("theme-toggle").className = 'light';
	window.localStorage.setItem('theme', 'dark');
}

function activateLightTheme() {
    document.getElementById('theme-toggle').checked = false;
    document.documentElement.setAttribute('data-theme', 'light');
    document.documentElement.classList.add('theme--light');
    document.documentElement.classList.remove('theme--dark');
	document.getElementById("theme-toggle").className = 'dark';
	window.localStorage.setItem('theme', 'light');
}

if (theme === "dark") {
    activateDarkTheme();
} else if (theme === "light") {
    activateLightTheme();
} else if  (userPrefers === "light") {
    activateDarkTheme();
} else {
    activateDarkTheme();
}

function modeSwitcher() {
	let currentMode = document.documentElement.getAttribute('data-theme');
	if (currentMode === "dark") {
	    activateLightTheme();
	} else {
	    activateDarkTheme();
	}
}
</script></div>
  </div>
</footer>


<script>
      window.FontAwesomeConfig = {
        searchPseudoElements: true
      }
    </script>
  </body>

</html>
